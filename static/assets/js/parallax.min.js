! function (t, i, e) {
    "use strict";

    // Parallax 클래스 생성자 함수
    function s(t, i) {
        // this.element: Parallax 효과가 적용될 DOM 요소 (t)
        this.element = t;
        // this.layers:  'layer' 클래스를 가진 모든 자식 요소들 (parallax 레이어들)
        this.layers = t.getElementsByClassName("layer");

        // data-* 속성들을 읽어서 설정 객체 (e)를 만듭니다.
        // data-* 속성이 없으면 undefined가 되고, 있으면 해당 값을 가져옵니다.
        var e = {
            calibrateX: this.data(this.element, "calibrate-x"), // x축 보정 여부
            calibrateY: this.data(this.element, "calibrate-y"), // y축 보정 여부
            invertX: this.data(this.element, "invert-x"),    // x축 반전 여부
            invertY: this.data(this.element, "invert-y"),    // y축 반전 여부
            limitX: this.data(this.element, "limit-x"),      // x축 제한 값
            limitY: this.data(this.element, "limit-y"),      // y축 제한 값
            scalarX: this.data(this.element, "scalar-x"),    // x축 스케일 (움직임 정도)
            scalarY: this.data(this.element, "scalar-y"),    // y축 스케일 (움직임 정도)
            frictionX: this.data(this.element, "friction-x"),  // x축 마찰 (움직임의 부드러움 정도)
            frictionY: this.data(this.element, "friction-y"),  // y축 마찰
            originX: this.data(this.element, "origin-x"),    // x축 원점 (0.0 ~ 1.0)
            originY: this.data(this.element, "origin-y")     // y축 원점 (0.0 ~ 1.0)
        };

        // data-* 속성이 null인 경우 (설정되지 않은 경우) 해당 속성을 삭제합니다.
        for (var s in e) null === e[s] && delete e[s];

        // 기본 설정 (r), 사용자 정의 설정 (i), data-* 속성 설정 (e)을 병합합니다.
        // 우선 순위:  i (사용자 정의) > e (data-*) > r (기본값)
        this.extend(this, r, i, e);

        // 보정 관련 변수 초기화
        this.calibrationTimer = null;   // 보정 타이머 ID
        this.calibrationFlag = !0;      // 보정 플래그 (처음에는 true로 설정)

        // Parallax 효과 활성화/비활성화 상태
        this.enabled = !1;

        // 레이어 깊이 (depth) 값을 저장할 배열
        this.depths = [];

        // requestAnimationFrame ID 저장
        this.raf = null;

        // 엘리먼트의 경계 (bounding rectangle) 정보
        this.bounds = null;

        // 엘리먼트 관련 위치/크기 변수들
        this.ex = 0;    // 엘리먼트 x 좌표 (left)
        this.ey = 0;    // 엘리먼트 y 좌표 (top)
        this.ew = 0;    // 엘리먼트 너비 (width)
        this.eh = 0;    // 엘리먼트 높이 (height)
        this.ecx = 0;   // 엘리먼트 중심 x 좌표
        this.ecy = 0;   // 엘리먼트 중심 y 좌표
        this.erx = 0;   // 엘리먼트 중심으로부터 가장 먼 x 거리 (오른쪽 or 왼쪽)
        this.ery = 0;   // 엘리먼트 중심으로부터 가장 먼 y 거리 (위쪽 or 아래쪽)

        // 윈도우 관련 위치/크기 변수들
        this.cx = 0;    // 윈도우 중심 x 좌표
        this.cy = 0;    // 윈도우 중심 y 좌표
        this.ix = 0;    // 입력 x 좌표 (마우스 또는 자이로스코프)
        this.iy = 0;    // 입력 y 좌표
        this.mx = 0;    // 스케일링 및 제한이 적용된 x 좌표
        this.my = 0;    // 스케일링 및 제한이 적용된 y 좌표
        this.vx = 0;    // x축 속도
        this.vy = 0;    // y축 속도


        // 이벤트 핸들러 함수들을 bind()를 사용하여 this 컨텍스트를 고정시킵니다.
        this.onMouseMove = this.onMouseMove.bind(this);              // 마우스 움직임 이벤트
        this.onDeviceOrientation = this.onDeviceOrientation.bind(this);  // 디바이스 방향 (자이로스코프) 이벤트
        this.onOrientationTimer = this.onOrientationTimer.bind(this);    // 방향 지원 감지 타이머
        this.onCalibrationTimer = this.onCalibrationTimer.bind(this);    // 보정 타이머
        this.onAnimationFrame = this.onAnimationFrame.bind(this);      // 애니메이션 프레임
        this.onWindowResize = this.onWindowResize.bind(this);          // 윈도우 크기 변경 이벤트

        // Parallax 효과 초기화
        this.initialise();
    }

    // 상수 및 기본 설정
    var n = "Parallax",     // 플러그인 이름
        o = 30,             // 자이로스코프 값 나누는 기준 값 (클수록 둔감)
        r = { // 기본 설정 객체
            relativeInput: !1,      // 상대적인 입력 사용 여부 (false: 윈도우 기준, true: 엘리먼트 기준)
            clipRelativeInput: !1,  // relativeInput이 true일 때, 엘리먼트 경계 내로 입력값 제한
            calibrationThreshold: 100, // 보정 임계값 (입력 변화량이 이 값보다 커야 보정)
            calibrationDelay: 500, // 보정 지연 시간 (ms)
            supportDelay: 500,     // 자이로스코프 지원 감지 지연 시간 (ms)
            calibrateX: !1,        // x축 보정 기본값
            calibrateY: !0,        // y축 보정 기본값
            invertX: !0,          // x축 반전 기본값
            invertY: !0,          // y축 반전 기본값
            limitX: !1,            // x축 제한 기본값 (false 또는 숫자)
            limitY: !1,            // y축 제한 기본값
            scalarX: 10,          // x축 스케일 기본값
            scalarY: 10,          // y축 스케일 기본값
            frictionX: .1,        // x축 마찰 기본값
            frictionY: .1,        // y축 마찰 기본값
            originX: .5,          // x축 원점 기본값
            originY: .5          // y축 원점 기본값
        };

    // extend(): 설정 객체 병합 (여러 객체를 하나의 객체로 합침)
    s.prototype.extend = function () {
        if (arguments.length > 1) {
            var t = arguments[0]; // 대상 객체 (첫 번째 인수)
            // 나머지 인수들을 순회하면서 속성을 대상 객체에 복사
            for (var i = 1, e = arguments.length; e > i; i++) {
                var s = arguments[i]; // 복사할 객체
                for (var n in s) t[n] = s[n]; // 속성 복사
            }
        }
    };

    // data(): data-* 속성 값을 가져오고, 적절한 타입으로 변환
    s.prototype.data = function (t, i) {
        return this.deserialize(t.getAttribute("data-" + i));
    };

    // deserialize(): 문자열을 boolean, null, number, string으로 변환
    s.prototype.deserialize = function (t) {
        return "true" === t ? !0 : "false" === t ? !1 : "null" === t ? null : !isNaN(parseFloat(t)) && isFinite(t) ? parseFloat(t) : t;
    };

    // camelCase():  하이픈(-)으로 연결된 문자열을 camelCase로 변환 (ex: "webkit-transform" -> "webkitTransform")
    s.prototype.camelCase = function (t) {
        return t.replace(/-+(.)?/g, function (t, i) {
            return i ? i.toUpperCase() : "";
        });
    };


    // transformSupport(): CSS transform 속성 (2D 또는 3D) 지원 여부 확인
    s.prototype.transformSupport = function (s) {
        // 가상의 div 엘리먼트를 생성하여 transform 속성 지원 여부를 테스트
        for (var n = i.createElement("div"), o = !1, r = null, a = !1, h = null, l = null, p = 0, c = this.vendors.length; c > p; p++)
            // vendor prefix (브라우저 공급업체 접두사)를 붙여서 transform 속성 확인
            if (null !== this.vendors[p] ? (h = this.vendors[p][0] + "transform", l = this.vendors[p][1] + "Transform") : (h = "transform", l = "transform"), n.style[l] !== e) {
                o = !0;  // transform 지원됨
                break;
            }

        // 2D 또는 3D transform 지원 여부에 따라 추가 검사
        switch (s) {
            case "2D":
                a = o; // 2D transform 지원 여부
                break;
            case "3D":
                if (o) { // transform이 지원되는 경우에만 3D transform 추가 검사
                    var m = i.body || i.createElement("body"),  // body 엘리먼트 가져오거나 생성
                        u = i.documentElement,                 // html 엘리먼트
                        y = u.style.overflow;                   // html 엘리먼트의 overflow 속성 값 저장

                    // body 엘리먼트가 없으면 body를 생성하고 임시로 스타일 설정
                    i.body || (u.style.overflow = "hidden", u.appendChild(m), m.style.overflow = "hidden", m.style.background = "");

                    // body에 가상의 div를 추가하고 3D transform 적용
                    m.appendChild(n);
                    n.style[l] = "translate3d(1px,1px,1px)";

                    // getComputedStyle()을 사용하여 실제로 적용된 transform 값을 가져옴
                    r = t.getComputedStyle(n).getPropertyValue(h);

                    // 적용된 값이 있고, "none"이 아니면 3D transform 지원됨
                    a = r !== e && r.length > 0 && "none" !== r;

                    // 원래 overflow 설정으로 복원하고, 임시 body 제거
                    u.style.overflow = y;
                    m.removeChild(n);
                }
        }
        return a; // 최종 3D transform 지원 여부 반환
    };

    // 전역 변수 및 플래그, 브라우저 prefixes, motion/orientation 지원 여부
    s.prototype.ww = null;       // 윈도우 너비 (window width)
    s.prototype.wh = null;       // 윈도우 높이 (window height)
    s.prototype.wcx = null;      // 윈도우 중심 x 좌표 (window center x)
    s.prototype.wcy = null;      // 윈도우 중심 y 좌표 (window center y)
    s.prototype.wrx = null;      // 윈도우 중심으로부터 가장 먼 x 거리
    s.prototype.wry = null;      // 윈도우 중심으로부터 가장 먼 y 거리
    s.prototype.portrait = null;   // 세로 모드 여부 (true: 세로, false: 가로)
    s.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);  // 데스크탑 여부 (모바일 기기가 아니면 true)
    s.prototype.vendors = [null, ["-webkit-", "webkit"], ["-moz-", "Moz"], ["-o-", "O"], ["-ms-", "ms"]];  // 브라우저 공급업체 접두사
    s.prototype.motionSupport = !!t.DeviceMotionEvent;         // DeviceMotionEvent 지원 여부 (가속도계)
    s.prototype.orientationSupport = !!t.DeviceOrientationEvent;  // DeviceOrientationEvent 지원 여부 (자이로스코프)
    s.prototype.orientationStatus = 0;        // DeviceOrientationEvent 상태 (0: 미지원, 1: 지원)
    s.prototype.transform2DSupport = s.prototype.transformSupport("2D");  // 2D transform 지원 여부
    s.prototype.transform3DSupport = s.prototype.transformSupport("3D"); // 3D transform 지원 여부
    s.prototype.propertyCache = {};       // CSS 속성 캐시 (vendor prefix가 적용된 속성 이름을 저장)

    // initialise():  Parallax 효과 초기화
    s.prototype.initialise = function () {
        // 3D transform을 지원하면, 엘리먼트에 "가속" 효과를 줌 (GPU 가속)
        this.transform3DSupport && this.accelerate(this.element);

        // 엘리먼트의 computed style (계산된 스타일)을 가져옴
        var i = t.getComputedStyle(this.element);

        // 엘리먼트의 position이 static이면 relative로 변경 (레이어 위치 지정을 위해)
        "static" === i.getPropertyValue("position") && (this.element.style.position = "relative");

        // 레이어 업데이트,  크기 업데이트, Parallax 활성화, 보정 타이머 시작
        this.updateLayers();
        this.updateDimensions();
        this.enable();
        this.queueCalibration(this.calibrationDelay); // calibrationDelay 이후 calibrate() 실행
    };

    // updateLayers():  레이어 요소들을 찾아서 초기화
    s.prototype.updateLayers = function () {
        // 'layer' 클래스를 가진 모든 자식 요소들을 다시 가져옴
        this.layers = this.element.getElementsByClassName("layer");
        this.depths = []; // depths 배열 초기화

        // 각 레이어를 순회하면서 스타일 설정 및 depth 값 저장
        for (var t = 0, i = this.layers.length; i > t; t++) {
            var e = this.layers[t];

            // 3D transform 지원하면 레이어 가속
            this.transform3DSupport && this.accelerate(e);

            // 첫 번째 레이어는 relative, 나머지는 absolute로 position 설정
            e.style.position = t ? "absolute" : "relative";
            e.style.display = "block";  // display: block으로 설정
            e.style.left = 0;           // left, top 초기화
            e.style.top = 0;

            // data-depth 속성 값을 읽어서 depths 배열에 저장 (없으면 0)
            this.depths.push(this.data(e, "depth") || 0);
        }
    };

    // updateDimensions(): 윈도우와 관련된 크기 및 위치 정보를 업데이트
    s.prototype.updateDimensions = function () {
        // 윈도우 너비, 높이
        this.ww = t.innerWidth;
        this.wh = t.innerHeight;

        // 윈도우 중심 좌표
        this.wcx = this.ww * this.originX;  // originX (default: 0.5)
        this.wcy = this.wh * this.originY;  // originY (default: 0.5)

        // 윈도우 중심으로부터 가장 먼 거리 (x, y)
        this.wrx = Math.max(this.wcx, this.ww - this.wcx);
        this.wry = Math.max(this.wcy, this.wh - this.wcy);
    };

    // updateBounds(): 엘리먼트의 경계(bounding rectangle)와 관련된 크기 및 위치 정보를 업데이트
    s.prototype.updateBounds = function () {
        // 엘리먼트의 boundingClientRect (경계)를 가져옴
        this.bounds = this.element.getBoundingClientRect();

        // 엘리먼트의 x, y 좌표 (left, top), 너비, 높이
        this.ex = this.bounds.left;
        this.ey = this.bounds.top;
        this.ew = this.bounds.width;
        this.eh = this.bounds.height;

        // 엘리먼트의 중심 좌표
        this.ecx = this.ew * this.originX;
        this.ecy = this.eh * this.originY;

        // 엘리먼트 중심으로부터 가장 먼 거리 (x, y)
        this.erx = Math.max(this.ecx, this.ew - this.ecx);
        this.ery = Math.max(this.ecy, this.eh - this.ecy);
    };

    // queueCalibration():  calibrationDelay 이후에 보정 타이머 (onCalibrationTimer)를 실행
    s.prototype.queueCalibration = function (t) {
        clearTimeout(this.calibrationTimer); // 이전 타이머 제거
        this.calibrationTimer = setTimeout(this.onCalibrationTimer, t); // t 밀리초 후에 onCalibrationTimer 실행
    };

    // enable(): Parallax 효과 활성화 (이벤트 리스너 등록)
    s.prototype.enable = function () {
        if (!this.enabled) { // 이미 활성화되지 않았으면
            this.enabled = !0; // 활성화 플래그 설정

            // 자이로스코프 지원 여부에 따라 이벤트 리스너 등록
            if (this.orientationSupport) {
                this.portrait = null;  // portrait 초기화
                t.addEventListener("deviceorientation", this.onDeviceOrientation);  // deviceorientation 이벤트 리스너 등록

                // supportDelay 이후에 onOrientationTimer 실행 (자이로스코프 지원 여부 확인)
                setTimeout(this.onOrientationTimer, this.supportDelay);
            } else {
                // 자이로스코프 미지원 시, 마우스 이벤트 사용
                this.cx = 0;  // 마우스 x 중심 좌표 초기화
                this.cy = 0;  // 마우스 y 중심 좌표 초기화
                this.portrait = !1; // 가로 모드로 고정
                t.addEventListener("mousemove", this.onMouseMove); // mousemove 이벤트 리스너 등록
            }

            // 윈도우 크기 변경 이벤트 리스너 등록
            t.addEventListener("resize", this.onWindowResize);

            // 애니메이션 프레임 시작
            this.raf = requestAnimationFrame(this.onAnimationFrame);
        }
    };

    // disable(): Parallax 효과 비활성화 (이벤트 리스너 제거)
    s.prototype.disable = function () {
        if (this.enabled) { // 이미 활성화되었으면
            this.enabled = !1; // 비활성화 플래그 설정

            // 자이로스코프 지원 여부에 따라 이벤트 리스너 제거
            if (this.orientationSupport) {
                t.removeEventListener("deviceorientation", this.onDeviceOrientation);
            } else {
                t.removeEventListener("mousemove", this.onMouseMove);
            }

            // 윈도우 크기 변경 이벤트 리스너 제거
            t.removeEventListener("resize", this.onWindowResize);

            // 애니메이션 프레임 중지
            cancelAnimationFrame(this.raf);
        }
    };

    // calibrate(): x축, y축 보정 값 설정
    s.prototype.calibrate = function (t, i) {
        this.calibrateX = t === e ? this.calibrateX : t;  // t가 undefined이면 기존 값 유지, 아니면 새로운 값 (true/false)
        this.calibrateY = i === e ? this.calibrateY : i;
    };

    // invert(): x축, y축 반전 설정
    s.prototype.invert = function (t, i) {
        this.invertX = t === e ? this.invertX : t;
        this.invertY = i === e ? this.invertY : i;
    };

    // friction(): x축, y축 마찰 값 설정
    s.prototype.friction = function (t, i) {
        this.frictionX = t === e ? this.frictionX : t;
        this.frictionY = i === e ? this.frictionY : i;
    };

    // scalar(): x축, y축 스칼라(움직임 정도) 값 설정
    s.prototype.scalar = function (t, i) {
        this.scalarX = t === e ? this.scalarX : t;
        this.scalarY = i === e ? this.scalarY : i;
    };

    // limit(): x축, y축 움직임 제한 값 설정
    s.prototype.limit = function (t, i) {
        this.limitX = t === e ? this.limitX : t;
        this.limitY = i === e ? this.limitY : i;
    };

    // origin(): x축, y축 원점 설정 (0.0 ~ 1.0, 엘리먼트 내에서의 상대적인 위치)
    s.prototype.origin = function (t, i) {
        this.originX = t === e ? this.originX : t;
        this.originY = i === e ? this.originY : i;
    };

    // clamp(): 값을 최소값과 최대값 사이로 제한
    s.prototype.clamp = function (t, i, e) {
        return t = Math.max(t, i), t = Math.min(t, e);
    };

    // css(): 엘리먼트에 CSS 스타일 적용 (vendor prefix 고려)
    s.prototype.css = function (t, i, s) {
        // 캐시된 속성 이름 확인 (vendor prefix가 이미 적용된 속성)
        var n = this.propertyCache[i];

        // 캐시된 속성이 없으면, vendor prefix를 붙여서 속성 이름 찾기
        if (!n)
            for (var o = 0, r = this.vendors.length; r > o; o++)
                if (n = null !== this.vendors[o] ? this.camelCase(this.vendors[o][1] + "-" + i) : i, t.style[n] !== e) {
                    // 찾은 속성 이름을 캐시에 저장
                    this.propertyCache[i] = n;
                    break;
                }
        // 찾은 속성 이름(n)으로 엘리먼트에 스타일 적용
        t.style[n] = s;
    };

    // accelerate(): 엘리먼트에 3D transform을 적용하여 GPU 가속 활성화
    s.prototype.accelerate = function (t) {
        // translate3d(0,0,0)를 적용하여 GPU 가속을 유도 (transform 연산이 GPU에서 처리되도록)
        this.css(t, "transform", "translate3d(0,0,0)");
        // preserve-3d: 자식 엘리먼트들이 3D 공간에 배치되도록
        this.css(t, "transform-style", "preserve-3d");
        // hidden: 엘리먼트의 뒷면을 숨김 (뒷면이 보이는 것을 방지)
        this.css(t, "backface-visibility", "hidden");
    };

    // setPosition(): 레이어의 위치 (left, top) 설정 (2D/3D transform 사용)
    s.prototype.setPosition = function (t, i, e) {
        i += "px", e += "px"; // "px" 단위 추가

        // 3D transform 지원하면 translate3d() 사용
        if (this.transform3DSupport) this.css(t, "transform", "translate3d(" + i + "," + e + ",0)");
        // 2D transform 지원하면 translate() 사용
        else if (this.transform2DSupport) this.css(t, "transform", "translate(" + i + "," + e + ")");
        // transform 미지원 시, style.left, style.top으로 위치 설정
        else t.style.left = i, t.style.top = e;
    };

    // onOrientationTimer():  자이로스코프 지원 여부 확인 (최초 1회 실행)
    s.prototype.onOrientationTimer = function () {
        // 자이로스코프를 지원하고, orientationStatus가 0 (미지원)이면
        if (this.orientationSupport && 0 === this.orientationStatus) {
            // Parallax 효과 비활성화, 자이로스코프 지원 플래그 false, Parallax 효과 다시 활성화
            this.disable(), this.orientationSupport = !1, this.enable();
        }
    };

    // onCalibrationTimer():  보정 플래그 (calibrationFlag)를 true로 설정 (보정 필요)
    s.prototype.onCalibrationTimer = function () {
        this.calibrationFlag = !0;
    };

    // onWindowResize():  윈도우 크기 변경 시,  updateDimensions() 호출
    s.prototype.onWindowResize = function () {
        this.updateDimensions();
    };

    // onAnimationFrame():  매 프레임마다 실행되는 핵심 로직 (레이어 위치 계산 및 적용)
    s.prototype.onAnimationFrame = function () {
        this.updateBounds(); // 엘리먼트 경계 업데이트

        // 입력값 변화량 계산 (이전 값과의 차이)
        var t = this.ix - this.cx,
            i = this.iy - this.cy;

        // 입력값 변화량이 보정 임계값(calibrationThreshold)보다 크면, 보정 실행
        (Math.abs(t) > this.calibrationThreshold || Math.abs(i) > this.calibrationThreshold) && this.queueCalibration(0);

        // 세로 모드 여부에 따라 mx, my 계산 (보정 및 반전 설정 고려)
        if (this.portrait) {
            this.mx = this.calibrateX ? i : this.iy; // calibrateX가 true이면 i(자이로 y 변화량) 사용, 아니면 iy
            this.my = this.calibrateY ? t : this.ix; // calibrateY가 true이면 t(자이로 x 변화량) 사용, 아니면 ix
        } else {
            this.mx = this.calibrateX ? t : this.ix; // calibrateX가 true이면 t(마우스 x 변화량) 사용, 아니면 ix
            this.my = this.calibrateY ? i : this.iy; // calibrateY가 true이면 i(마우스 y 변화량) 사용, 아니면 iy
        }

        // mx, my에 스칼라 값 적용 (움직임 정도)
        this.mx *= this.ew * (this.scalarX / 100);
        this.my *= this.eh * (this.scalarY / 100);

        // limitX, limitY가 설정되어 있으면, mx, my 값을 제한
        isNaN(parseFloat(this.limitX)) || (this.mx = this.clamp(this.mx, -this.limitX, this.limitX));
        isNaN(parseFloat(this.limitY)) || (this.my = this.clamp(this.my, -this.limitY, this.limitY));

        // vx, vy (속도) 계산 (현재 위치와 이전 속도, 마찰 계수 적용)
        this.vx += (this.mx - this.vx) * this.frictionX; // frictionX (default: 0.1)
        this.vy += (this.my - this.vy) * this.frictionY;

        // 각 레이어를 순회하면서 위치 설정
        for (var e = 0, s = this.layers.length; s > e; e++) {
            var n = this.layers[e],      // 현재 레이어
                o = this.depths[e],     // 현재 레이어의 depth
                r = this.vx * o * (this.invertX ? -1 : 1), // x축 움직임 (invertX에 따라 반전)
                a = this.vy * o * (this.invertY ? -1 : 1); // y축 움직임 (invertY에 따라 반전)
            this.setPosition(n, r, a);   // 레이어 위치 설정
        }

        // 다음 프레임 요청 (재귀 호출)
        this.raf = requestAnimationFrame(this.onAnimationFrame);
    };

    // onDeviceOrientation():  자이로스코프 이벤트 핸들러
    s.prototype.onDeviceOrientation = function (t) {
        // 데스크탑이 아니고, beta(x축 회전), gamma(y축 회전) 값이 null이 아니면 (자이로스코프 값 정상)
        if (!this.desktop && null !== t.beta && null !== t.gamma) {
            this.orientationStatus = 1; // 자이로스코프 지원 상태를 1 (지원)로 설정

            // beta, gamma 값을 o (30)으로 나누어서 정규화 (값의 범위를 줄임)
            var i = (t.beta || 0) / o,  // x축 회전 각도
                e = (t.gamma || 0) / o; // y축 회전 각도

            // 현재 화면 방향 (세로/가로) 감지
            var s = this.wh > this.ww;

            // 화면 방향이 변경되었으면 (portrait 값이 변경되었으면)
            if (this.portrait !== s) {
                this.portrait = s;     // portrait 값 업데이트
                this.calibrationFlag = !0; // 보정 필요 (화면 방향이 바뀌었으므로)
            }

            // 보정이 필요하면, cx, cy (기준 자이로 값) 업데이트
            if (this.calibrationFlag) {
                this.calibrationFlag = !1; // 보정 플래그 false (보정 완료)
                this.cx = i;            // x축 기준 자이로 값
                this.cy = e;            // y축 기준 자이로 값
            }

            // ix, iy (현재 자이로 값) 업데이트
            this.ix = i;
            this.iy = e;
        }
    };

    // onMouseMove(): 마우스 이벤트 핸들러
    s.prototype.onMouseMove = function (t) {
        var i = t.clientX,  // 마우스 x 좌표
            e = t.clientY;  // 마우스 y 좌표

        // 자이로스코프를 지원하지 않고, relativeInput이 true이면 (엘리먼트 기준 입력)
        if (!this.orientationSupport && this.relativeInput) {

            // clipRelativeInput이 true이면, 마우스 좌표를 엘리먼트 경계 내로 제한
            if (this.clipRelativeInput) {
                i = Math.max(i, this.ex);
                i = Math.min(i, this.ex + this.ew);
                e = Math.max(e, this.ey);
                e = Math.min(e, this.ey + this.eh);
            }

            // 엘리먼트 기준 상대 좌표 계산 (0.0 ~ 1.0)
            this.ix = (i - this.ex - this.ecx) / this.erx;
            this.iy = (e - this.ey - this.ecy) / this.ery;

        } else {
            // 윈도우 기준 상대 좌표 계산 (0.0 ~ 1.0)
            this.ix = (i - this.wcx) / this.wrx;
            this.iy = (e - this.wcy) / this.wry;
        }
    };

    // 전역 객체(window)에 Parallax 클래스 등록
    t[n] = s;

}(window, document); // 즉시 실행 함수 (IIFE) - window, document를 인자로 전달

// requestAnimationFrame 폴리필 (polyfill):  requestAnimationFrame이 없는 구형 브라우저를 위한 대체 함수
! function () {
    for (var t = 0, i = ["ms", "moz", "webkit", "o"], e = 0; e < i.length && !window.requestAnimationFrame; ++e) window.requestAnimationFrame = window[i[e] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[e] + "CancelAnimationFrame"] || window[i[e] + "CancelRequestAnimationFrame"];
    window.requestAnimationFrame || (window.requestAnimationFrame = function (i) {
        var e = (new Date).getTime(),
            s = Math.max(0, 16 - (e - t)),
            n = window.setTimeout(function () {
                i(e + s)
            }, s);
        return t = e + s, n
    }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) {
        clearTimeout(t)
    })
}();